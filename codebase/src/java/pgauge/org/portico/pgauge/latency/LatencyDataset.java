/*
 *   Copyright 2009 The Portico Project
 *
 *   This file is part of pgauge (a sub-project of Portico).
 *
 *   pgauge is free software; you can redistribute it and/or modify
 *   it under the terms of the Common Developer and Distribution License (CDDL) 
 *   as published by Sun Microsystems. For more information see the LICENSE file.
 *   
 *   Use of this software is strictly AT YOUR OWN RISK!!!
 *   If something bad happens you do not have permission to come crying to me.
 *   (that goes for your lawyer as well)
 *
 */
package org.portico.pgauge.latency;

import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Stores information about latency generated by a {@link Requester} during a benchmarking run.
 * All information is GIVEN to the dataset in nanos, but converted internally to micros (as nanos
 * really is too low to be measuring in for this stuff - but there is only a getCurrentMillis() or
 * nanotime() for getting time information from the system).
 */
public class LatencyDataset
{
	//----------------------------------------------------------
	//                    STATIC VARIABLES
	//----------------------------------------------------------

	//----------------------------------------------------------
	//                   INSTANCE VARIABLES
	//----------------------------------------------------------
	private List<Long> latency;

	//----------------------------------------------------------
	//                      CONSTRUCTORS
	//----------------------------------------------------------
	public LatencyDataset()
	{
		this.latency = new ArrayList<Long>();
	}

	//----------------------------------------------------------
	//                    INSTANCE METHODS
	//----------------------------------------------------------

	public void record( long latencyInNanos )
	{
		this.latency.add( TimeUnit.NANOSECONDS.toMicros(latencyInNanos) );
	}

	public int size()
	{
		return latency.size();
	}

	public long get( int index )
	{
		return latency.get( index );
	}

	public List<Long> getRawData()
	{
		return latency;
	}
	
	public long getAverage()
	{
		long total = 0;
		for( Long iteration : latency )
			total += iteration;
		
		return total / latency.size();
	}

	public double getStandardDeviation()
	{
		// big ups to Mandeep Sandhu for figuring the maths out for me
		// previously, when there was sufficient variance in the set, or you had a giant
		// dataset (or both), the calculation I was using would fail. I calculated the
		// sum of all the squares first in a temp var, but this number got so big that
		// the temp var rolled over past it's max possible value (in an unsigned long!).
		// This approach calculates things in a rolling average sort of way, without the
		// need to sum everything up first. Much, much nicer.
		double rollingMean = 0.0d;
		double rollingVariance = 0.0d;
		double rollingStddev = 0.0d;
		int count = 1;

		for( Long current : latency )
		{
			count++;
			double temp = rollingMean;
			rollingMean += (current-rollingMean) / count;
			
			temp = (current-temp);
			rollingVariance += (count-1)*temp*temp / count;
			rollingStddev = Math.sqrt( rollingVariance/(count-1) );
		}
		
		return rollingStddev;
	}
	
	public long getAverageWithinTwoStandardDeviations()
	{
		double stddev = getStandardDeviation();
		double average = getAverage();
		double min = average - (stddev*2);
		double max = average + (stddev*2);
		
		double sum = 0;
		long sumCount = 0;
		for( Long current : latency )
		{
			if( current < min || current > max )
				continue;

			sum += current;
			sumCount++;
		}
		
		return (long)sum / sumCount;
	}
	
	/**
	 * This average is derived by sorting the set of all results and ditching the top 10% and the
	 * bottom 10%, then taking the average of what's left.
	 */
	public long getEightyAverage()
	{
		// sort the dataset
		ArrayList<Long> copy = new ArrayList<Long>( latency );
		Collections.sort( copy );
		
		// ignore the first and last 10%
		int start = copy.size()/10;
		int end = copy.size() - start;
		long total = 0;
		int counted = 0;
		for( int i = start; i < end; i++ )
		{
			total += copy.get(i);
			++counted;
		}
		
		return total / counted;
	}
	
	public long getLow()
	{
		long low = Long.MAX_VALUE;
		for( Long iteration : latency )
		{
			if( iteration < low )
				low = iteration;
		}
		
		return low;
	}
	
	public long getHigh()
	{
		long high = 0;
		for( Long iteration : latency )
		{
			if( iteration > high )
				high = iteration;
		}
		
		return high;
	}

	///////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////// File Operations /////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////
	public void writeToFile( String location ) throws Exception
	{
		// create the directory and file
		File file = new File( location );
		if( file.exists() == false )
		{
			file.getParentFile().mkdirs();
			file.createNewFile();
		}

		PrintWriter writer = new PrintWriter( file );
		for( Long current : latency )
			writer.println( ""+current );
		
		writer.flush();
		writer.close();
	}

	//----------------------------------------------------------
	//                     STATIC METHODS
	//----------------------------------------------------------
}
